"use strict";(self.webpackChunk_2_oodlib=self.webpackChunk_2_oodlib||[]).push([[8335],{7228:(e,i,r)=>{r.r(i),r.d(i,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var t=r(74848),o=r(28453);const s={id:new Date("2023-11-15T00:00:00.000Z")},l="Introduction",a={id:"lecture-notes/algorithms/Wed Nov 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)",title:"Introduction",description:"Summary",source:"@site/docs/lecture-notes/algorithms/2023-11-15.md",sourceDirName:"lecture-notes/algorithms",slug:"/lecture-notes/algorithms/Wed Nov 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)",permalink:"/oodlib/docs/lecture-notes/algorithms/Wed Nov 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)",draft:!1,unlisted:!1,editUrl:"https://github.com/2ood/oodlib/blob/master/docs/lecture-notes/algorithms/2023-11-15.md",tags:[],version:"current",frontMatter:{id:"Wed Nov 15 2023 00:00:00 GMT+0000 (Coordinated Universal Time)"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/algorithms/2023-11-13"},next:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/algorithms/2023-11-22"}},d={},h=[{value:"Binary tree",id:"binary-tree",level:2},{value:"Array representation",id:"array-representation",level:2},{value:"Full binary tree",id:"full-binary-tree",level:2},{value:"Complete binary tree",id:"complete-binary-tree",level:2},{value:"Insertion operation in MaxHeap",id:"insertion-operation-in-maxheap",level:2},{value:"Time complexity of insertion",id:"time-complexity-of-insertion",level:4},{value:"Removal operation in Max Heap.",id:"removal-operation-in-max-heap",level:2},{value:"Time complexity of removal&amp;readjust.",id:"time-complexity-of-removalreadjust",level:4}];function c(e){const i={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Summary"})}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"keywords"})}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"TODO"})}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"HW"})}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Exercise"}),"*"]}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Next time"})}),"\n"]}),"\n",(0,t.jsx)(i.hr,{}),"\n",(0,t.jsx)(i.h1,{id:"heap",children:"Heap"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Binary tree"}),"\n",(0,t.jsx)(i.li,{children:"Array representation of binary tree"}),"\n",(0,t.jsx)(i.li,{children:"Complete binary tree"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"binary-tree",children:"Binary tree"}),"\n",(0,t.jsx)(i.p,{children:"height,\ndepth 0 is root, depth 1 is the next level, .."}),"\n",(0,t.jsx)(i.h2,{id:"array-representation",children:"Array representation"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"store higher leaves first, left to right."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Wee need to preserve.."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Element value itself"}),"\n",(0,t.jsx)(i.li,{children:"parent-child relationship."}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["If a node is at node ",(0,t.jsx)(i.code,{children:"i"}),"\nthe left child is at ",(0,t.jsx)(i.code,{children:"2*i"}),", right child is at ",(0,t.jsx)(i.code,{children:"2*i+1"}),", its parent is at ",(0,t.jsx)(i.code,{children:"[i/2]"})]}),"\n",(0,t.jsx)(i.h2,{id:"full-binary-tree",children:"Full binary tree"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:["every leaves of height is filled.\n",(0,t.jsx)(i.code,{children:"2^h-1"})," Nodes\nheight is log n ?"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"complete-binary-tree",children:"Complete binary tree"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"there should be no empty parts in array representation"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"![[Pasted image 20231115145210.png]]\nup is a complete binary tree. down is not a complete binary tree."}),"\n",(0,t.jsx)(i.h1,{id:"max-heap--min-heap",children:"Max heap & Min heap"}),"\n",(0,t.jsx)(i.p,{children:"Max heap is"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"a complete binary tree"}),"\n",(0,t.jsx)(i.li,{children:"parent element are always bigger than child"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Min heap is"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"a complete binary tree"}),"\n",(0,t.jsx)(i.li,{children:"parent element are always smaller than child."}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"This doen't mean that heap is a sorted array."}),"\n**They only guarantee the min, or max value."]}),"\n",(0,t.jsx)(i.h2,{id:"insertion-operation-in-maxheap",children:"Insertion operation in MaxHeap"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:["You first insert the new element ",(0,t.jsx)(i.strong,{children:"at the bottom, and move to the top"})]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["compare with parent, and if parent is smaller, swap.\nThis way, the property of ",(0,t.jsx)(i.strong,{children:"complete binary tree"})," is preserved."]}),"\n",(0,t.jsx)(i.h4,{id:"time-complexity-of-insertion",children:"Time complexity of insertion"}),"\n",(0,t.jsxs)(i.p,{children:["The time complexity of insertion is ",(0,t.jsxs)(i.strong,{children:["$O(\\log",n,")$"]})," at maximum, which is the height of the tree.\nminimum O(1), maximum ",(0,t.jsxs)(i.strong,{children:["$O(\\log",n,")$"]})]}),"\n",(0,t.jsx)(i.h2,{id:"removal-operation-in-max-heap",children:"Removal operation in Max Heap."}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"you only pop the top of the heap."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"popping is easy, but you need to readjust the remaining elements."}),"\n",(0,t.jsx)(i.p,{children:"How to readjust?"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"end element move to the front, and compare with the children."}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"time-complexity-of-removalreadjust",children:"Time complexity of removal&readjust."}),"\n",(0,t.jsxs)(i.p,{children:["The time complexity of readjustment is minimum O(1), maximum ",(0,t.jsxs)(i.strong,{children:["$O(\\log",n,")$"]})]}),"\n",(0,t.jsx)(i.h1,{id:"heapsort",children:"HeapSort"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"if you pop element one by one from a heap and combine it, it results a sorted array."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"![[Pasted image 20231115152534.png]]\nwe do n removal&readjust. so time complexity is $O(n\\log n)$."}),"\n",(0,t.jsxs)(i.p,{children:["#todo ",":write"," about time complexity, and comparison"]}),"\n",(0,t.jsx)(i.h1,{id:"heapify",children:"Heapify"}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsx)(i.p,{children:"Adjusting downwards"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"heap creating time complexity to $O(n)$"}),"\n",(0,t.jsx)(i.p,{children:"From the back element, check if the downards tree is a heap.\nElse, make it a heap.\nnumber of swaps for each height is $log n$...?"})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var r=i(96540);const t={},o=r.createContext(t);function s(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);