"use strict";(self.webpackChunk_2_oodlib=self.webpackChunk_2_oodlib||[]).push([[8020],{52624:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(74848),r=i(28453);const s={},o="Introduction",l={id:"lecture-notes/digital_design/2024-03-18",title:"Introduction",description:"Summary",source:"@site/docs/lecture-notes/digital_design/2024-03-18.md",sourceDirName:"lecture-notes/digital_design",slug:"/lecture-notes/digital_design/2024-03-18",permalink:"/oodlib/docs/lecture-notes/digital_design/2024-03-18",draft:!1,unlisted:!1,editUrl:"https://github.com/2ood/oodlib/blob/master/docs/lecture-notes/digital_design/2024-03-18.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/digital_design/2024-03-13"},next:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/digital_design/2024-03-20"}},d={},c=[{value:"Gray code",id:"gray-code",level:2},{value:"Why do we need concept of gray codes?",id:"why-do-we-need-concept-of-gray-codes",level:3},{value:"Error Detection Codes",id:"error-detection-codes",level:2},{value:"Serial Data Bit representation",id:"serial-data-bit-representation",level:2},{value:"Diagrams, truth table, and function.",id:"diagrams-truth-table-and-function",level:2},{value:"useful two-binary-variable operations",id:"useful-two-binary-variable-operations",level:2},{value:"Logic Circuits",id:"logic-circuits",level:2},{value:"Basic Axioms of Boolean Algebra",id:"basic-axioms-of-boolean-algebra",level:2}];function a(e){const n={blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Summary"})}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"keywords"})}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"TODO"})}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"HW"})}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Exercise"}),"*"]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Next time"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"gray-code",children:"Gray code"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"The codes are sequenced so as the adjacent code has only one bit difference."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(76350).A+"",width:"681",height:"433"})}),"\n",(0,t.jsx)(n.h3,{id:"why-do-we-need-concept-of-gray-codes",children:"Why do we need concept of gray codes?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To detect ",(0,t.jsx)(n.strong,{children:"how many bits are corrupted"})," in the data."]}),"\n",(0,t.jsx)(n.li,{children:"When the data is changed, the value difference is equal to the number of corrupted bits."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"error-detection-codes",children:"Error Detection Codes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Parity bits"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It adjusts so that the number f 1s in a group to be even(even parity) or odd(odd parity)"}),"\n",(0,t.jsx)(n.li,{children:"It cannot correctly detect multiple bit errors."}),"\n",(0,t.jsx)(n.li,{children:"It cannot fix errors."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"serial-data-bit-representation",children:"Serial Data Bit representation"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(98848).A+"",width:"1117",height:"604"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"boolean-algebra",children:"Boolean Algebra"}),"\n",(0,t.jsx)(n.h2,{id:"diagrams-truth-table-and-function",children:"Diagrams, truth table, and function."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The dot symbol stands for 'not' operation; the triangle symbol stands for 'buffer' operation. Combined, it means 'not' operation."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"truth table is the only definitive way to express operation."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:'truth table uses "HIGH", "LOW", "X" as the entity(Due to the underlying hardware tech).'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"X means either Low or high logic level: Don't care condition"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"not is typographically expressed in prime or overbar."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"overbar is a complement expression."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"useful-two-binary-variable-operations",children:"useful two-binary-variable operations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"AND $F(x_1,x_2) = x_1 x_2$"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"OR $F(x_1,x_2) = x_1+x_2$"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"XOR (OR, but not both) $F(x_1,x_2) = x_1\u2295x_2$"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"NAND"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"NOR"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"E-XOR"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"NAND, NOR has duality"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"All the other operations can be implemented with NAND and NOR gates; it is universal."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"logic-circuits",children:"Logic Circuits"}),"\n",(0,t.jsx)(n.p,{children:"There are canonical form or others.\nCanonical form definitively expresses truth tables."}),"\n",(0,t.jsx)(n.h2,{id:"basic-axioms-of-boolean-algebra",children:"Basic Axioms of Boolean Algebra"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"only concerns three operations only (AND, OR, Complement)"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},76350:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/20240318130824-4a972ea7d1bde13a9142175fc5243b44.png"},98848:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/20240318132147-9f86240626b41edf81556cdc135f00b8.png"},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);