"use strict";(self.webpackChunk_2_oodlib=self.webpackChunk_2_oodlib||[]).push([[5299],{49175:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});var o=i(74848),r=i(28453);const s={},l="Introduction",t={id:"lecture-notes/algorithms/2023-10-04",title:"Introduction",description:"Summary",source:"@site/docs/lecture-notes/algorithms/2023-10-04.md",sourceDirName:"lecture-notes/algorithms",slug:"/lecture-notes/algorithms/2023-10-04",permalink:"/oodlib/docs/lecture-notes/algorithms/2023-10-04",draft:!1,unlisted:!1,editUrl:"https://github.com/2ood/oodlib/blob/master/docs/lecture-notes/algorithms/2023-10-04.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/algorithms/Mon Sep 25 2023 00:00:00 GMT+0000 (Coordinated Universal Time)"},next:{title:"Introduction",permalink:"/oodlib/docs/lecture-notes/algorithms/2023-10-11"}},c={},d=[{value:"Two approach of DP",id:"two-approach-of-dp",level:3},{value:"How do you identify the problem can be solved by DP?",id:"how-do-you-identify-the-problem-can-be-solved-by-dp",level:3},{value:"principle of optimality",id:"principle-of-optimality",level:3},{value:"Divide n Conquer vs. DP",id:"divide-n-conquer-vs-dp",level:3},{value:"Greedy vs. DP",id:"greedy-vs-dp",level:3},{value:"Problem w/ Recursion; Why do we need DP?",id:"problem-w-recursion-why-do-we-need-dp",level:2},{value:"Fibonacci in Memoization",id:"fibonacci-in-memoization",level:2},{value:"Fibonacci in Tabulation",id:"fibonacci-in-tabulation",level:2}];function a(e){const n={blockquote:"blockquote",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Summary"})}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"keywords"})}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"TODO"})}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"HW"})}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Exercise"}),"*"]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next time"}),"\nsolution of Knapsack problem."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h1,{id:"recap",children:"Recap"}),"\n",(0,o.jsx)(n.p,{children:"master's theorem, asymptotic notations, substitutions"}),"\n",(0,o.jsx)(n.p,{children:"what algorithms did we learn?\nlinear search, binary search, all kinds of sorting,"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h1,{id:"contents-forward",children:"Contents Forward"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"DP or Greedy"}),"\n",(0,o.jsx)(n.li,{children:"Fibonacci"}),"\n",(0,o.jsx)(n.li,{children:"Zero one, unbounded, simple knapsack"}),"\n",(0,o.jsx)(n.li,{children:"matrix chain multiplication"}),"\n",(0,o.jsx)(n.li,{children:"longest common subsequence"}),"\n",(0,o.jsx)(n.li,{}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"write in resursive first, and convert to DP algorithm."}),"\n"]}),"\n",(0,o.jsx)(n.h1,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["used for solving ",(0,o.jsx)(n.strong,{children:"Optimizing Problem"}),"; minimize or maximize sth.\nmemo. optimization can be solved using Greedy and DP."]}),"\n",(0,o.jsx)(n.li,{children:"reduces time complexity of prior algorithms."}),"\n",(0,o.jsxs)(n.li,{children:["should ",(0,o.jsx)(n.strong,{children:"try all possible solutions"})," and pick up the best solution."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"two-approach-of-dp",children:"Two approach of DP"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"memoization(Top down)."}),"\n",(0,o.jsx)(n.li,{children:"Tabulation (Bottom up)."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"how-do-you-identify-the-problem-can-be-solved-by-dp",children:"How do you identify the problem can be solved by DP?"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["to implement, the problem should contain ",(0,o.jsx)(n.strong,{children:"overlapping subproblems"}),".\nDP follows ",(0,o.jsx)(n.strong,{children:"Principle of Optimality"})]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"principle-of-optimality",children:"principle of optimality"}),"\n",(0,o.jsx)(n.p,{children:"problems can be solved by taking a sequence of decision."}),"\n",(0,o.jsx)(n.h3,{id:"divide-n-conquer-vs-dp",children:"Divide n Conquer vs. DP"}),"\n",(0,o.jsxs)(n.p,{children:["similarity : combine subproblem solution to make final solution\ndifference :\nDivide n Conquer when ",(0,o.jsx)(n.strong,{children:"disjoint"})," subproblems,\nthere will be no same call with same input.\nex. merge sort.\nDP when ",(0,o.jsx)(n.strong,{children:"overlapping"})," subproblems.\nex. fibonacci."]}),"\n",(0,o.jsx)(n.h3,{id:"greedy-vs-dp",children:"Greedy vs. DP"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Greedy sees the local optimum."}),"\n",(0,o.jsx)(n.li,{children:"Greedy do not deal with multiple possible solutions"}),"\n",(0,o.jsx)(n.li,{children:"Greedy do not guarantee the correct answer."}),"\n",(0,o.jsx)(n.li,{children:"Greedy is faster."}),"\n",(0,o.jsx)(n.li,{children:"Greedy deal with some uncertain assumptions."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"#todo : see slide 5. (see image)"}),"\n",(0,o.jsx)(n.p,{children:"memo. Greedy\nGreedy is based on local optimum. step by step,"}),"\n",(0,o.jsx)(n.h2,{id:"problem-w-recursion-why-do-we-need-dp",children:"Problem w/ Recursion; Why do we need DP?"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"stack overflow."}),"\n"]}),"\n",(0,o.jsx)(n.h1,{id:"dp1-fibonacci",children:"DP#1, Fibonacci."}),"\n",(0,o.jsx)(n.h2,{id:"fibonacci-in-memoization",children:"Fibonacci in Memoization"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"recursive"})," approach, top-down approach."]}),"\n",(0,o.jsx)(n.p,{children:"Steps."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"initialize an 1D array (with invalid results, like -1)."}),"\n",(0,o.jsx)(n.li,{children:"after calling functions, fill the result on array."}),"\n",(0,o.jsx)(n.li,{children:"When overlapping functions, refer the array and get the result w/o calculating."}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Still recursive."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"fibonacci-in-tabulation",children:"Fibonacci in Tabulation"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"iterative"})," approach, using loops."]}),"\n",(0,o.jsx)(n.p,{children:"Steps."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"make an array."}),"\n",(0,o.jsx)(n.li,{children:"iterating from 0 to desitnation, calculate each fibonacci one by one."}),"\n"]}),"\n",(0,o.jsx)(n.h1,{id:"dp2-1-01-knapsack",children:"DP#2-1, 0/1 Knapsack."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"bag with a finite capacity bag.\neach item has weight and price.\nmaximize the contained price of the bag."}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Take, or don't take the item."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>t});var o=i(96540);const r={},s=o.createContext(r);function l(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);